<% if include_imports { %>
#[cfg(feature = "parser")]
use pax_compiler::parsing::TypeParsable;
<% } %>
#[cfg(feature = "parser")]
impl <%= pascal_identifier %> {
    pub fn parse_to_manifest(mut ctx: pax_compiler::parsing::ParsingContext) -> (pax_compiler::parsing::ParsingContext, String) {
        let self_type_id = <%= pascal_identifier %>::get_type_id("<%= pascal_identifier %>");
        match ctx.visited_type_ids.get(&self_type_id as &str) {
            None => {
                //First time visiting this file/source â€” parse the relevant contents
                //then recurse through child nodes, unrolled here in the macro as
                //parsed from the template
                ctx.visited_type_ids.insert(self_type_id.clone());
                let PASCAL_IDENTIFIER = "<%= pascal_identifier %>";
                ctx.template_map.insert(PASCAL_IDENTIFIER.to_string(), self_type_id.clone());
                let template_map= ctx.template_map.clone();

                let mut property_definitions : Vec<pax_compiler::manifest::PropertyDefinition> = vec![];

                // Populate `PropertyDefinition`s
                <% for spd in static_property_definitions { %>
                    //Here we bridge from pure static analysis into some dynamic analysis via `parser`, in order
                    //to fully qualify module paths for scoped atomic types.

                    let mut fully_qualified_constituent_types = vec![];

                    //Special-handle the root scoped_resolvable_type (the one whose properties
                    //must be available as nested symbols in PAXEL, like `foo.bar`).  Specifically,
                    //we want need the Vec<PropertyDefinitions> for that root type.
                    let (mut ctx, mut sub_property_definitions) = <%= spd.root_scoped_resolvable_type %>::parse_type_to_manifest(ctx);

                    <% for scoped_resolvable_type in spd.scoped_resolvable_types { %>
                        let fqd = <%= scoped_resolvable_type %>::get_type_id("<%= scoped_resolvable_type %>");

                        fully_qualified_constituent_types.push(
                            fqd
                        );

                        //Parse each scoped resolvable type, but no need to track the child property_definitions like we did for the root scoped resolvable type
                        let (mut ctx, _) = <%= scoped_resolvable_type %>::parse_type_to_manifest(ctx);
                    <% } %>

                    let property_type_id = <%= spd.root_scoped_resolvable_type %>::get_type_id("<%= spd.pascal_identifier %>");

                    let (mut ctx, _type_def) =  pax_compiler::parsing::assemble_type_definition(
                        ctx,
                        fully_qualified_constituent_types.clone(),
                        sub_property_definitions,
                        &property_type_id,
                    );

                    property_definitions.push(pax_compiler::manifest::PropertyDefinition {
                        name: "<%= spd.field_name %>".to_string(),
                        type_id: property_type_id,
                        flags: None,
                    });

                <% } %>

                let (mut ctx, self_type_definition) = pax_compiler::parsing::assemble_type_definition(
                    ctx,
                    vec![],
                    property_definitions.clone(),
                    &self_type_id,
                );

                let comp_def = pax_compiler::parsing::assemble_primitive_definition(
                    PASCAL_IDENTIFIER,
                    module_path!(),
                    "<%=  primitive_instance_import_path  %>".to_string(),
                    &self_type_id,
                );
                ctx.component_definitions
                    .insert(self_type_id.clone(), comp_def);
                (ctx, self_type_id)
            },
            _ => (ctx, self_type_id), //early return; this file has already been parsed
        }
    }
}

#[cfg(feature = "parser")]
impl pax_compiler::parsing::TypeParsable for <%= pascal_identifier %> {

    fn get_type_id(pascal_identifier: &str) -> String {
        let chopped_type = {
            if pascal_identifier.contains("::") {
                pascal_identifier.split("::").last().unwrap()
            } else {
                pascal_identifier
            }
        };
        module_path!().to_owned().replacen("parser", "crate", 1) + "::" + chopped_type
    }
}