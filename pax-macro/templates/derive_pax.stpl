<% if include_imports { %>
    #[cfg(feature = "parser")]
    use pax_compiler::parsing::Reflectable;
    #[cfg(feature = "parser")]
    use serde_json;
<% } %>

<% if args_full_component.as_ref().is_some() && args_full_component.as_ref().unwrap().is_main_component { %>
    // For the main (application-root) component only, a `main` is generated for the `parser` bin target.
    // This method bootstraps the parsing process, parsing not only the main/application-root component
    // but every component/primitive found in its extended render tree. This main method
    // also returns the parsed, serialized PaxManifest via stdio (println)
    #[cfg(feature = "parser")]
    pub fn main() {

        let mut ctx = pax_compiler::parsing::ParsingContext::default();

        let (mut ctx, _) = <%= pascal_identifier %>::parse_to_manifest(ctx);

        let manifest = pax_compiler::manifest::PaxManifest {
            components: ctx.component_definitions,
            main_component_type_id: ctx.main_component_type_id,
            expression_specs: None,
            type_table: ctx.type_table,
        };

        //Send data back to parent process by printing to stdout
        println!("{}", &serde_json::to_string_pretty(&manifest).unwrap());
        std::process::exit(0);
    }

    //For main component only, and only when we're NOT parsing, include reexports
    //Parsing is excluded because the `pub mod pax_reexports` snippet can only be generated
    //after parsing.

    <%= args_full_component.as_ref().unwrap().reexports_snippet %>
<% } else { %>
    //WARNING: No pax_reexports were introduced by macro because no PAX_DIR env was specified for compiled project.
<% } %>


#[cfg(feature = "parser")]
impl <%= pascal_identifier %> {
    // For all components, a parse_to_manifest is generated under the `parser` feature
    // so that the parser binary may traverse all dependencies.
    // This method is the recursive workhorse of parsing logic.
    // One way to look at this, in conjunction with the `parser` bin target: a solution to "coordinating between macros"
    pub fn parse_to_manifest(mut ctx: pax_compiler::parsing::ParsingContext) -> (pax_compiler::parsing::ParsingContext, String) {

        let self_type_id = <%= pascal_identifier %>::get_type_id();
        let mut property_definitions = vec![];

        // Populate `PropertyDefinition`s
        <% for spd in &static_property_definitions { %>
            //Here we bridge from pure static analysis into some dynamic analysis via `parser`, in order
            //to fully qualify module paths for scoped atomic types.

            let mut fully_qualified_constituent_types = vec![];

            //Special-handle the root scoped_resolvable_type (the one whose properties
            //must be available as nested symbols in PAXEL, like `foo.bar`).
            let (mut ctx, mut sub_property_definitions) = <%= spd.root_scoped_resolvable_type %>::parse_type_to_manifest(ctx);

            <% for scoped_resolvable_type in &spd.scoped_resolvable_types { %>
                let fqd = <%= scoped_resolvable_type %>::get_type_id();

                fully_qualified_constituent_types.push(
                    fqd
                );

                //Parse each scoped resolvable type, but no need to track the sub_property_definitions like we did for the root scoped resolvable type
                let (mut ctx, _) = <%= scoped_resolvable_type %>::parse_type_to_manifest(ctx);
            <% } %>

            let property_type_id = <%= spd.root_scoped_resolvable_type %>::get_type_id();
            let iterable_type_id = <%= spd.root_scoped_resolvable_type %>::get_iterable_type_id();

            let (mut ctx, _type_def) =  pax_compiler::parsing::assemble_type_definition(
                ctx,
                fully_qualified_constituent_types.clone(),
                sub_property_definitions,
                iterable_type_id,
                &property_type_id,
            );

            property_definitions.push(pax_compiler::manifest::PropertyDefinition {
                name: "<%= spd.field_name %>".to_string(),
                type_id: property_type_id,
                flags: None,
            });
        <% } %>

        match ctx.visited_type_ids.get(&self_type_id as &str) {

            None => {
                //First time visiting this file/source â€” parse the relevant contents
                //then recurse through child nodes, unrolled here in the macro as
                //parsed from the template
                ctx.visited_type_ids.insert(self_type_id.clone().into());

                <% if args_full_component.as_ref().is_some() { %>
                    <% for dep in args_full_component.as_ref().unwrap().template_dependencies.clone() { %>
                    let (mut ctx, dep_type_id) = <%= dep %>::parse_to_manifest(ctx);
                    ctx.template_map.insert("<%= dep %>".into(), dep_type_id.clone());
                    <% } %>

                    //FUTURE: mitigate injection risk here -- notable risk if dealing with untrusted input.  A mitigation may be to sanitize/validate/parse `raw_pax` before templating.
                    const raw_pax: &str = r#####"
                        <%= args_full_component.as_ref().unwrap().raw_pax %>
                    "#####;
                <% } %>

                const PASCAL_IDENTIFIER : &str = "<%= pascal_identifier %>";

                let (mut ctx, self_type_definition) =  pax_compiler::parsing::assemble_type_definition(
                    ctx,
                    vec![pax_compiler::parsing::clean_module_path(module_path!()) + "::" + PASCAL_IDENTIFIER],
                    property_definitions.clone(),
                    None,
                    &self_type_id,
                );

                <% if args_full_component.as_ref().is_some() { %>
                    let template_map = ctx.template_map.clone();
                    let (mut ctx, comp_def) =
                        pax_compiler::parsing::assemble_component_definition(
                            ctx,
                            &raw_pax,
                            PASCAL_IDENTIFIER,
                            <%= args_full_component.as_ref().unwrap().is_main_component %>,
                            template_map,
                            &pax_compiler::parsing::clean_module_path(module_path!()),
                            &self_type_id,
                        );
                <% } %>
                <% if args_struct_only_component.as_ref().is_some() { %>
                    let (mut ctx, comp_def) =
                        pax_compiler::parsing::assemble_struct_only_component_definition(
                            ctx,
                            PASCAL_IDENTIFIER,
                            &pax_compiler::parsing::clean_module_path(module_path!()),
                            &self_type_id,
                        );
                <% } %>
                <% if args_primitive.as_ref().is_some() { %>
                    let comp_def = pax_compiler::parsing::assemble_primitive_definition(
                        PASCAL_IDENTIFIER,
                        &pax_compiler::parsing::clean_module_path(module_path!()),
                        "<%=  args_primitive.as_ref().unwrap().primitive_instance_import_path  %>".to_string(),
                        &self_type_id,
                    );
                <% } %>

                ctx.component_definitions
                    .insert(self_type_id.clone(), comp_def);

                (ctx, self_type_id)
            },
            _ => (ctx, self_type_id), //early return; this file has already been parsed
        }
    }
}

<% if !is_custom_interpolatable { %>
    impl pax::api::Interpolatable for <%= pascal_identifier %> {}
<% } %>

#[cfg(feature = "parser")]
impl pax_compiler::parsing::Reflectable for <%= pascal_identifier %> {

    fn get_self_pascal_identifier() -> String {
        "<%= pascal_identifier %>".to_string()
    }

    fn get_type_id() -> String {
        let PASCAL_IDENTIFIER  = <%= pascal_identifier %>::get_self_pascal_identifier();
        let chopped_type = {
            if PASCAL_IDENTIFIER.contains("::") {
                PASCAL_IDENTIFIER.split("::").last().unwrap().to_string()
            } else {
                PASCAL_IDENTIFIER
            }
        };
        pax_compiler::parsing::clean_module_path(module_path!()) + "::" + &chopped_type
    }

    <% if args_struct_only_component.as_ref().is_some() || args_full_component.as_ref().is_some() { %>
        fn parse_type_to_manifest(mut ctx: pax_compiler::parsing::ParsingContext) -> (pax_compiler::parsing::ParsingContext, Vec<pax_compiler::manifest::PropertyDefinition>) {
            let self_type_id = <%= pascal_identifier %>::get_type_id();
            let mut property_definitions : Vec<pax_compiler::manifest::PropertyDefinition> = vec![];

            // Populate `PropertyDefinition`s
            <% for spd in &static_property_definitions { %>

                let mut fully_qualified_constituent_types = vec![];

                //Special-handle the root scoped_resolvable_type (the one whose properties
                //must be available as nested symbols in PAXEL, like `foo.bar`).
                let (mut ctx, mut sub_property_definitions) = <%= spd.root_scoped_resolvable_type %>::parse_type_to_manifest(ctx);

                <% for scoped_resolvable_type in &spd.scoped_resolvable_types { %>
                    let fqd = <%= scoped_resolvable_type %>::get_type_id();

                    fully_qualified_constituent_types.push(
                        fqd
                    );

                    //Parse each scoped resolvable type, but no need to track the child property_definitions like we did for the root scoped resolvable type
                    let (mut ctx, _) = <%= scoped_resolvable_type %>::parse_type_to_manifest(ctx);
                <% } %>

                let property_type_id = <%= spd.root_scoped_resolvable_type %>::get_type_id();
                let iterable_type_id = <%= spd.root_scoped_resolvable_type %>::get_iterable_type_id();

                let (mut ctx, _type_def) =  pax_compiler::parsing::assemble_type_definition(
                    ctx,
                    fully_qualified_constituent_types.clone(),
                    sub_property_definitions,
                    iterable_type_id,
                    &property_type_id,
                );

                property_definitions.push(pax_compiler::manifest::PropertyDefinition {
                    name: "<%= spd.field_name %>".to_string(),
                    type_id: property_type_id,
                    flags: None,
                });
            <% } %>

            match &ctx.visited_type_ids.get(&self_type_id as &str) {
                None => {
                    //First time visiting this file/source

                    ctx.visited_type_ids.insert(self_type_id.clone().into());

                    let PASCAL_IDENTIFIER = "<%= pascal_identifier %>";

                    let (mut ctx, self_type_definition) =  pax_compiler::parsing::assemble_type_definition(
                        ctx,
                        vec!["<%= pascal_identifier %>".to_string()],
                        property_definitions.clone(),
                        None,
                        &self_type_id,
                    );

                    let (mut ctx, type_def) =
                        pax_compiler::parsing::assemble_struct_only_component_definition(
                            ctx,
                            PASCAL_IDENTIFIER,
                            &pax_compiler::parsing::clean_module_path(module_path!()),
                            &self_type_id,
                        );

                    ctx.component_definitions
                        .insert(self_type_id.clone(), type_def);

                    (ctx, property_definitions)
                },
                _ => (ctx, property_definitions), //early return; this file has already been parsed
            }
        }
    <% } %>

}