<% if include_imports { %>
#[cfg(feature = "parser")]
use pax::internal::{Reflectable};
#[cfg(feature = "parser")]
use pax_compiler::parsing::TypeParsable;
<% } %>
#[cfg(feature = "parser")]
impl pax_compiler::parsing::TypeParsable for <%= pascal_identifier %> {

    fn parse_type_to_manifest(mut ctx: pax_compiler::parsing::ParsingContext) -> (pax_compiler::parsing::ParsingContext, Vec<pax_compiler::manifest::PropertyDefinition>) {

        let self_type_id = <%= pascal_identifier %>::get_type_id();
        let mut property_definitions : Vec<pax_compiler::manifest::PropertyDefinition> = vec![];

        // Populate `PropertyDefinition`s
        <% for spd in static_property_definitions { %>

            let mut fully_qualified_constituent_types = vec![];


            //Special-handle the root scoped_resolvable_type (the one whose properties
            //must be available as nested symbols in PAXEL, like `foo.bar`).  Specifically,
            //we want need the Vec<PropertyDefinitions> for that root type.
            let (mut ctx, mut sub_property_definitions) = <%= spd.root_scoped_resolvable_type %>::parse_type_to_manifest(ctx);

            <% for scoped_resolvable_type in spd.scoped_resolvable_types { %>
                let fqd = <%= scoped_resolvable_type %>::get_fully_qualified_path("<%= scoped_resolvable_type %>");

                fully_qualified_constituent_types.push(
                    fqd
                );

                //Parse each scoped resolvable type, but no need to track the child property_definitions like we did for the root scoped resolvable type
                let (mut ctx, _) = <%= scoped_resolvable_type %>::parse_type_to_manifest(ctx);
            <% } %>

            let property_type_id = <%= spd.root_scoped_resolvable_type %>::get_type_id();

            let (mut ctx, _type_def) =  pax_compiler::parsing::assemble_type_definition(
                ctx,
                "<%= spd.original_type %>",
                fully_qualified_constituent_types.clone(),
                sub_property_definitions,
                &property_type_id,
            );

            property_definitions.push(pax_compiler::manifest::PropertyDefinition {
                name: "<%= spd.field_name %>".to_string(),
                type_id: property_type_id,
                flags: None,
            });
        <% } %>

        match ctx.visited_type_ids.get(&self_type_id as &str) {
            None => {
                //First time visiting this file/source

                ctx.visited_type_ids.insert(self_type_id.clone().into());

                let PASCAL_IDENTIFIER = "<%= pascal_identifier %>";

                let (mut ctx, self_type_definition) =  pax_compiler::parsing::assemble_type_definition(
                    ctx,
                    "<%= pascal_identifier %>",
                    vec!["<%= pascal_identifier %>".to_string()],
                    property_definitions.clone(),
                    &self_type_id,
                );


                let (mut ctx, type_def) =
                    pax_compiler::parsing::assemble_struct_only_component_definition(
                        ctx,
                        PASCAL_IDENTIFIER,
                        module_path!(),
                        &self_type_id,
                    );

                ctx.component_definitions
                    .insert(self_type_id.clone(), type_def);

                (ctx, property_definitions)
            },
            _ => (ctx, property_definitions), //early return; this file has already been parsed
        }
    }
}

#[cfg(feature = "parser")]
impl pax_message::reflection::Reflectable for <%= pascal_identifier %> {

    fn get_type_id() -> String {
        file!().to_string() + "#" + "<%= pascal_identifier %>"
    }

    fn get_fully_qualified_path(atomic_self_type: &str) -> String {
        //this type may come in qualified, e.g. with `crate::some::mod::some::Type`
        //in this case, we want only `Type`.  This is a crude heuristic and may need to be revisited.
        let chopped_type = {
            if atomic_self_type.contains("::") {
                atomic_self_type.split("::").last().unwrap()
            } else {
                atomic_self_type
            }
        };
        module_path!().to_owned().replacen("parser", "crate", 1) + "::" + chopped_type
    }
}