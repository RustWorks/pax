
//Prelude: Rust
use std::cell::RefCell;
use std::collections::{HashMap, VecDeque};
use std::ops::Deref;
use std::rc::Rc;
//Prelude: Pax
use pax_runtime_api::numeric::Numeric;
use pax_runtime_api::{Size, SizePixels, PropertyInstance, PropertyLiteral, Size2D, Transform2D};
use pax_core::{ComponentInstance, RenderNodePtr, PropertyExpression, RenderNodePtrList, RenderTreeContext, ExpressionContext, PaxEngine, RenderNode, InstanceRegistry, HandlerRegistry, InstantiationArgs, ConditionalInstance, SlotInstance, StackFrame};
use pax_core::pax_properties_coproduct::{PropertiesCoproduct, TypesCoproduct};
use pax_core::repeat::{RepeatInstance};
use piet_common::RenderContext;

// generate imports, pointing to userland cartridge `pub mod pax_reexports`
{% for import in imports %}
use {{ import }};
{% endfor %}

//pull in entire const token stream here e.g. `const JABBERWOCKY : &str = r#"â€™Twas brillig, and the slithy toves `...
{% for const in consts %}
    {{ const }}
{% endfor %}

pub fn instantiate_expression_table<R: 'static + RenderContext>() -> HashMap<usize, Box<dyn Fn(ExpressionContext<R>) -> TypesCoproduct>> {
    let mut vtable: HashMap<usize, Box<dyn Fn(ExpressionContext<R>) -> TypesCoproduct>> = HashMap::new();

    {% for expression_spec in expression_specs %}
    //{{ expression_spec.input_statement}}
    vtable.insert({{ expression_spec.id }}, Box::new(|ec: ExpressionContext<R>| -> TypesCoproduct {
        {% for invocation in expression_spec.invocations %}
            let {{ invocation.escaped_identifier }} = {
                let properties = if let Some(sf) = (*ec.stack_frame).borrow().peek_nth({{ invocation.stack_offset }}) {
                    Rc::clone(&sf)
                } else {
                    Rc::clone(&ec.stack_frame)
                }.borrow().deref().get_properties();
                let properties = &*(*properties).borrow();

                {# if this is a `repeat source expression` and it's a `vec` (rather than range), we want to
                    re-wrap each repeated element into a PropertiesCoproduct::x, where x is either a primitive
                    (numeric or nonnumeric), or it's a known PropertiesCoproduct type, a struct attached to some Pax component

                    The reason we need to do this is because the userland struct is e.g. a Vec<RectDef>,
                    as opposed to a Vec<PropertiesCoproduct> (or more specifically: a Vec<Rc<PropertiesCoproduct>>)
                    And what we need to iterate over with Repeat is a Vec<Rc<PropertiesCoproduct>>
                        What else could Repeat get away with iterating over?


                    At this juncture: is there an easier way to handle userland iterables?
                    Property<Vec<RectDef>>, vs., say, PropertyVec<RectDef>

                    And do we need to wrap RectDef properties in Property<T> ?
                        We could include "read-only" properties when detecting properties at macro-time (instead of only Property<T>)
                        This would allow us to use simple structs inside PAXEL without .get/.set, Box, or PropertyLiteral

                #}

                {% if invocation.is_binding_repeat_elem %}

                    if let PropertiesCoproduct::RepeatItem(elem, i) = properties {
                        {% if invocation.is_iterable_numeric %}
                            {# For known numeric primitives, we can safely deref-copy and wrap in Numeric #}
                            let unwrapped = if let PropertiesCoproduct::{{invocation.pascalized_iterable_type}}(i) = **elem {i} else {unreachable!()};
                            Numeric::from(unwrapped)
                        {% elif invocation.is_iterable_primitive_nonnumeric %}
                            elem.clone()
                        {% else %}
                            {# This should be iterating over a `Rc<PropertiesCoproduct>`, so pass that forward #}
                            Rc::clone(elem)
                        {% endif %}

                    } else {unreachable!()}

                {% elif invocation.is_binding_repeat_i %}
                    if let PropertiesCoproduct::RepeatItem(_, i) = properties {
                        {# We're binding to `i`, an index, so wrap it in `Numeric` #}
                        Numeric::from(*i)
                    } else {unreachable!()}
                {% else %}
                    if let PropertiesCoproduct::{{ invocation.properties_coproduct_type }}(p) = properties {
                        {% if invocation.is_numeric_property %}
                            Numeric::from(p.{{invocation.root_identifier}}.get())
                        {% else %}
                            p.{{invocation.root_identifier}}.get().clone()
                        {% endif %}
                    } else {unreachable!()}
                {% endif %}
            }{{ invocation.nested_symbol_tail_literal }};
        {% endfor %}

        {% if expression_spec.is_repeat_source_iterable_expression %}
            {# We have a Vec<T> and we need to rewrap it into a Vec<Rc<PropertiesCoproduct>> #}
            {% for invocation in expression_spec.invocations %}
                let {{ invocation.escaped_identifier }} = {{ invocation.escaped_identifier }}.iter().map(|t|{
                    Rc::new(PropertiesCoproduct::{{invocation.pascalized_iterable_type}}(t.clone()))
                }).collect::<Vec<Rc<PropertiesCoproduct>>>();
            {% endfor %}
        {% endif %}

        #[allow(unused_parens)]
        TypesCoproduct::{{ expression_spec.pascalized_return_type }}(
            {{ expression_spec.output_statement }}
        )
    }));
    {% endfor %}

    vtable
}

//Begin component factory literals
{% for factory_literal in component_factories_literal %}
    {{ factory_literal }}
{% endfor %}
